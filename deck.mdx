export { components } from "mdx-deck-code-surfer"
export theme from "./theme"

# Relax

---

# Forget Best Practices

---

# Come with Me on a Journey

---

# Through Metaprogramming

---

> _Programming_

> "code processes user input"

---

> _Metaprogramming_

> "code processes itself"

---

```javascript
let person = { name: "John" }
//The code is looking at itself
Object.keys(person).forEach(key => {
  console.log(key) //"name"
})
----
* > Familiar Metaprogramming
3 > Object.keys processes person
```

---

# This Presentation is About Proxies

> My name is John Lindquist

---

# Proxies are Metaprogramming

> Code that processes itself

---

# Why Should You Care?

Because it opens a whole new world of possibilities

---

```js
let person = {
  first: "John"
}

person = logger(person)

person.first = "Mindy"
----
* > console.logs "first: John - Mindy"
1:3 > Create an object
5 > Invoke a function that returns a Proxy
7 > Assign "first" to "Mindy"
```

---

```js
person.first = "Mindy"

set(target, key, value) {
  // Do whatever you want here!
  target[key] = value
}
----
* > A set trap
1 > Make assignment
3 > Trap assignment!
4:5 > Do _anything_ inside the trap
```

---

```js
set(target, key, value) {
  //Reflection knows if assignment succeeded
  return Reflect.set(target, key, value)
}
----
* > Proper Trap
3 > Use Reflect.set to check success
```

---

```js
person.first = "John"

let handler = {
  set(target, key, value) {
    return Reflect.set(target, key, value)
  }
}
----
* > Traps belong to handlers
3 > The handler
4 > the "set" trap
1[0],4[3] > The Target
1[2],4[5] > The key
1[5],4[7] > The value
```

---

```js
new Proxy(person, handler)
----
* > Proxy receives a Target and a Handler
1[4] > Target
1[6] > Handler
```

---

```js
const logger = obj => {
  let handler = {
    set(target, key, value) {
      console.log(`${key}: ${target[key]} -> ${value}`)
      return Reflect.set(target, key, value)
    }
  }

  return new Proxy(obj, handler)
}
----
* > Full Logger Implementation
4 > Logging logic
```

---

## Sure, logging is useful, but what else can I do?

---

```js
let effect = current => {
  //render, request, whatever!
}

let person = {
  name: "John"
}

person = observable(person, effect)

person.name = "Mindy"
----
* > Callbacks/Reactive
9 > Proxy creation
11 > Make assignment
1:3 > Callback invoked
```

---

```js
export const observable = (obj, callback) => {
  const handler = {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)
      if (success) {
        callback(target)
      }
      return success
    }
  }

  return new Proxy(obj, handler)
}
----
* > Observable implementation
4 > Set the value
5:7 > If "set" works, invoke callback with updated target
```

---

# Bad Ideas

---

### Install my bad ideas

## npm i @johnlindquist/has-bad-ideas

---

```js
import { track, review } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = track(person)
----
* > Track and Review
1 > Import track and review
9 > Track creates a Proxy
```

---

```js
person.first = "Mindy"
person.last = "Smith"
person.age = 36
----
* > Make Some Changes
```

---

```js
review(person)
//[Object, Object, Object, Object]
review(person, -1)
//{first: "Mindy", last: "Smith", age: 37}
review(person, -2)
//{first: "Mindy", last: "Lindquist", age: 37}
----
* > Use "review" to view history
1:2 > The entire history
3:6 > Or previous snapshots
```

---

```js
const map = new WeakMap()

export const track = obj => {
  map.set(proxy, [{ ...obj }])

  const proxy = new Proxy(obj, {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)

      if (success) {
        map.set(proxy, [...map.get(proxy), {...target}])
      }

      return success
    }
  })

  return proxy
}
----
* > "track" Implementation
1 > Create a Map to map Proxies to Histories
4 > Store a clone of the intial target
10:12 > Store clones of future targets
```

---

```js
export const review = (proxy, index) => {
  const history = map.get(proxy)
  if (index === undefined) {
    return history
  }
  if (index < 0) {
    return history[history.length + index - 1]
  }
  return history[index]
}

----
* > "review" implementation
2 > get the history from the proxy
4,7,9 > return full history or snapshot
```

---

```js
import { box } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = box(person)

----
* > Lock it in a box
9 > Create a Proxy with "box"
```

---

```js
person.first = "Mindy"
//throws "I'm in a box!"
----
* > Throw an error when attempting "set"
```

---

```js
person.first()
//"John"
person.first("Mindy")
//{...person, first: "Mindy"}
----
* > Instead, all properties are getters/setters
1:2 > Getter
3:4 > Setter

```

---

```js
let shout = str => string.toUpperCase()
person.first(shout)
//{...person, name:"JOHN"}
----
* > Setters also accept functions
1 > A function that uppercases a string
2:3 > Pass the function to the "setter"
```

---

```js
 let handler = {
    set() {
      throw "I'm in a box!"
    },
    [...]
 }

----

 * > The "set" implementation
 2:4 > Don't even try it!
```

---

```js
get(target, key) {
  return value => {
    if (typeof value === "function")
      return new Proxy(
        { ...target, [key]: value(Reflect.get(target, key)) },
        handler
      )
    if (value) {
      return new Proxy({ ...target, [key]: value }, handler)
    }
    return Reflect.get(target, key)
  }
}


----
* > The "get" implementation
2 > Return a function
3,8 > Check the function argument
4:7 > If function, apply to value, return Proxy
9 > If value, set and return Proxy
11 > Or get the value
```

---

```js
person
  .first(shout)
  .last("Smith")
  .age(i => i + 1)
//{first: "JOHN", last: "Smith", age: 38}
----
* > Since "setters" return the Proxy
1 > Let's
2 > chain
3 > together
4 > properties!
5 > ğŸ˜‚
```

---

# Speaking of "chain" ğŸ¤”

---

```js
import { chain } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = chain(person)

----
* > Lodash All the Things ğŸ¤ª
9 > "chain" creates a Proxy
```

---

```js
person.first
  .replace("oh", "a")
  .repeat(3)
  .value()

//"JanJanJan"
----
* > Now every property has all lodash methods!
```

---

```js
import  _ from "lodash"
export const chain = obj => {
  const handler = {
    set() {
      throw "I'm in a box!"
    },
    get(target, key) {
      return _.chain(Reflect.get(target, key))
    }
  }

  return new Proxy(obj, handler)
}
----
* > Full "chain" implementation
8 > Return the wrapped value
```

---

# Pointless? Probably!

---

> We reactive-ed

> We lodash-ed

## What about the lodash of reactive programming...

---

```js
import { rxify } from "@johnlindquist/has-bad-ideas"
import { switchMap, mapTo } from "rxjs/operators"
import { interval } from "rxjs"

let person = {
  name: "John"
}

person = rxify(person)
----
* > How about some RxJS ğŸ˜
9 > Create the Proxy
```

---

```js
person
  .name(
    switchMap(name => {
      return interval(1000).pipe(mapTo(name))
    })
  )
  .subscribe(console.log)

person.name = "Mindy"

----
* > Log the name out every second
2,6 > Properties accept operators and return Observables
3:5 > So pass in whatever you want
7 > Then subscribe to changes

```

https://codesandbox.io/s/7z5j45mwv6

---

```js
let first$ = person.first()
let last$ = person.last()

combineLatest(first$, last$)
  .pipe(map(([first, last]) => `${first} ${last}`))
  .subscribe(console.log)

// "John Lindquist"
// "Mindy Lindquist"
// "Mindy Smith"

person.first = "Mindy"
person.last = "Smith"

----
* > Welcome to crazy town
1:2 > Grab two property streams
4:6 > Combine them for a good time ğŸ‰
12:13 > Setting values
8:10 > Pushes them through the stream


```

https://codesandbox.io/s/jvwp7lk5q3

---

## Async Properties? Easy!

<br />

## But how about _dynamic_ async properties!

---

```js
import { createApi } from "@johnlindquist/has-bad-ideas"

let api = createApi("https://swapi.co/api")

----
* > Create an api
3 > "api" is now a Proxy

```

---

```js
async function main() {
  //'get' request to https://swapi.co/api/people
  let people = await api.people()

  //'get' request to https://swapi.co/api/people/1
  let person = await api.people(1)
}

main()

----
* > Get `/people` from api:
2:3 > "people()" requests "/people"
5:6 > "people(1)" requests "/people/1"
```

https://codesandbox.io/s/73qv66745j

---

```js
get(target, key) {
  return async function(id = "") {
    const url = `${url}/${key}/${id}`
    const response = await fetch(url)
    if (response.ok) {
      return response.json()
    }

    return Promise.resolve({ error: "Malformed Request" })
  }
}

----
* > "createApi" implementation
2 > "get" returns an async function
3 > by parsing the "key" and "id"
4 > and await'ing a fetch
6:9 > then returning json or an error
```

---

# ğŸ’¡ Good Ideas ğŸ’¡

---

```js
//ramda lens
R.lensPath(["images", "avatar", "big"])
----
* > Traditional Lenses use Strings ğŸ¤®
2[6] > Ew
2[9] > Yuck
2[12] > Gross
```

---

```js
let _ = lensProxy()

_.images.avatar.big
----
* > How About a Lens Proxy!
3[2] > No
3[4] > Strings
3[6] > Here
3 > Recursive Trapped Properties ğŸ‰
```

---

```js
import { lens as _ } from "@johnlindquist/has-bad-ideas"

let provider = _.contact.email.provider
let person = { contact: { email: { provider: "gmail" } } }

let value = provider(person)

console.log(value)
// gmail
----
* > The basic idea
3 > Chained properties create a function
4,6 > The function "focuses" on object
```

---

```js
let handler = {
  keys: [],
  get(target, key) {
    this.keys.push(key)

    return new Proxy(obj => {
      return this.keys.reduce((acc, key) => {
        return Reflect.get(acc, key)
      }, obj)
    }, handler)
  }
}

----
* > "lens" implementation
6 > Return a Proxy
2,4 > Gather keys
7,9[3] > Reduce keys onto the object
8 > Return the value

```

---

# npm i focused

https://github.com/yelouafi/focused/

### (a much better proxy lens implementation)

---

# npm i immer

https://github.com/mweststrate/immer

### A Return to the JavaScript Basics

---

```js
import produce from "immer"

let nums = [1, 2]

let push3 = produce(draft => {
  draft.push(3)
})

let newNums = push3(nums)
// [1, 2, 3]
----
* > Blend Mutable and Immutable
3,9,10 > Our function creates a new object
5[2,5] > "produce" creates the function
5[7] > "draft" is a proxy
6 > which you mutate
* > ğŸ¤¯
```

---

```js
let person = {
  name: "John",
  contact: {
    email: {
      provider: "gmail"
    }
  }
}

let changeProvider = produce(draft => {
  //It doesn't get simpler
  draft.contact.email.provider = "AOL"
})

let personAOL = changeProvider(person)

----
* > No more deep cloning/merging
5 > "provider" is pretty deep
11,12 > But so easy to update!

```

---

```js
let reducer = produce((state, action) => {
  let todo = action.payload

  switch (action.type) {

    case "ADD":
      state.push(todo)
      break

    case "UPDATE":
      let index = state.findIndex(t => todo.id === t.id)
      state[index].done = true
      break

    case "DELETE":
      let index = state.findIndex(t => todo.id === t.id)
      state.splice(index, 1)
      break
  }
})

----
* > Complex Reducers Begone!
1[7] > "state" is a draft
6,7 > Add? Easy
10:12 > Update? No problem
15:17 > Delete? Piece of ğŸ°


```

---

```js
import { compose } from "ramda"

let person = {
  first: "John"
}

let mindyify = produce(draft => {
  draft.first = "Mindy"
})

let shout = produce(draft => {
  draft.first += "!"
})

let mindyShout = compose(
  shout,
  mindyify
)

let loudMindy = mindyShout(person)

----
* > Immer functions even compose!
7,11 > They're just functions
15:20 > So build them together
```

---

```js
// Whatever Evan said before me
// I hope... :)

----
* > Vue 3 Reactivity
```

---

# Summary

## Do whatever you want ğŸ¤·â€â™‚ï¸

---
