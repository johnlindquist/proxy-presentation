export theme from "./theme"

# Relax

---

# Forget Best Practices

---

# Come with Me on a Journey

---

# Through Metaprogramming

---

> _Programming_

> "code processes user input"

---

> _Metaprogramming_

> "code processes itself"

---

## Familiar Metaprogramming

```js
let person = { name: "John" }
//The code is looking at itself
Object.keys(person).forEach(key => {
  console.log(key) //"name"
})
```

---

# This Presentation is About Proxies

> My name is John Lindquist

---

# Proxies are Metaprogramming

> Code that processes itself

---

# Why Should You Care?

Because it opens a whole new world of possibilities

---

## Log All Property Changes

```js
let person = {
  first: "John"
}

person = logger(person)

person.first = "Mindy"
/*
  console.log shows:
  first: John -> Mindy
*/
```

---

## Trap Properties

```js
person.first = "Mindy"

//TRAPPED!
set(target, key, value) {
  //do whatever you want here!
  target[key] = value
}
```

---

## Proper Trap

```js
set(target, key, value) {
  //Reflection knows if assignment succeeded
  return Reflect.set(target, key, value)
}
```

---

## Traps Belong to Handlers

```js
let handler = {
  //The "set" trap
  set(target, key, value) {
    return Reflect.set(target, key, value)
  }
}
```

## Proxy Receives Target and Handler

```js
new Proxy(person, handler)
```

---

## Full "Logger"

```js
const logger = obj => {
  let handler = {
    set(target, key, value) {
      console.log(`${key}: ${target[key]} -> ${value}`)
      return Reflect.set(target, key, value)
    }
  }

  return new Proxy(obj, handler)
}
```

---

## Sure, logging is useful, but what else can I do?

---

## Reactive/Callbacks on Change

```js
let effect = current => {
  //render, request, whatever!
}

let person = {
  name: "John"
}

person = observable(person, effect)

person.name = "Mindy"
```

---

```js
export const observable = (obj, callback) => {
  const handler = {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)
      if (success) {
        callback(target)
      }
      return success
    }
  }

  return new Proxy(obj, handler)
}
```

---

# Bad Ideas

---

## Install My Bad Ideas

```bash
npm i @johnlindquist/has-bad-ideas
```

---

# Track and Review

```js
import { track, review } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = track(person)
```

---

# Make Changes

```js
person.first = "Mindy"
person.last = "Smith"
person.age = 36
```

## Review the entire history

```js
review(person) //[Object, Object, Object, Object]
```

## Or a previous version

```js
review(person, -1) //{first: "Mindy", last: "Smith", age: 37}
review(person, -2) //{first: "Mindy", last: "Lindquist", age: 37}
```

---

## Lock it in a box

```js
import { box } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = box(person)
```

---

## Throw Error on "set"

```js
person.first = "Mindy" //throws "I'm in a box!"
```

---

## All Properties are Getter/Setters

```js
person.first() //"John"
person.first("Mindy") //{...person, first: "Mindy"}
```

---

## Setters Accept Functions

```js
let shout = str => string.toUpperCase()
person.first(shout) //{...person, name:"JOHN"}
```

---

## Chain Together Prop Calls

```js
person
  .first(shout)
  .last("Smith")
  .age(i => i + 1)
//{first: "JOHN", last: "Smith", age: 38}
```

---

# Speaking of "chain" ðŸ¤”

---

## Lodash All the Things ðŸ¤ª

```js
import { chain } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = chain(person)
```

---

## Every Property Has All Lodash Methods

```js
person.first
  .replace("oh", "a")
  .repeat(3)
  .value()

//"JanJanJan"
```

## Pointless? Probably!

---

> We reactive-ed

> We lodash-ed

## What about the lodash of reactive programming...

---

## RxJS Time

```js
import { rxify } from "@johnlindquist/has-bad-ideas"
import { switchMap, mapTo } from "rxjs/operators"
import { interval } from "rxjs"

let person = {
  name: "John"
}

person = rxify(person)
```

---

## Log the Name Every Second

```js
person
  .name(
    switchMap(name => {
      return interval(1000).pipe(mapTo(name))
    })
  )
  .subscribe(console.log)

person.name = "Mindy"
```

https://codesandbox.io/s/7z5j45mwv6

---

## Wat?

```js
let first$ = person.first()
let last$ = person.last()

combineLatest(first$, last$)
  .pipe(map(([first, last]) => `${first} ${last}`))
  .subscribe(console.log)

// "John Lindquist"
// "Mindy Lindquist"
// "Mindy Smith"

person.first = "Mindy"
person.last = "Smith"
```

https://codesandbox.io/s/jvwp7lk5q3

---

## Async Properties? Easy!

<br />

## But how about _dynamic_ async properties!

---

## Create API

```js
import { createApi } from "@johnlindquist/has-bad-ideas"

let api = createApi("https://swapi.co/api")
```

---

Get `/people` from api:

```js
async function main() {
  //'get' request to https://swapi.co/api/people
  let people = await api.people()
}

main()
```

---

Get `/people/1` from api:

```js
//'get' request to https://swapi.co/api/people/1
let person = await api.people(1)
```

https://codesandbox.io/s/73qv66745j

---

# ðŸ’¡ Good Ideas ðŸ’¡

---

## Traditional Lenses

Strings ðŸ¤®

```js
//ramda lens
R.lensPath(["images", "avatar", "big"])
```

<br />

## Lens Proxy

Recursive Trapped Properties ðŸŽ‰

```js
let _ = lensProxy()

_.images.avatar.big
```

---

## Basic Idea

```js
import { lens as _ } from "@johnlindquist/has-bad-ideas"

let provider = _.contact.email.provider
let person = { contact: { email: { provider: "gmail" } } }

let value = provider(person)

console.log(value)
// John
```

---

## Gather Keys, Return Proxies

```js
let handler = {
  keys: [],
  get(target, key) {
    this.keys.push(key)

    return new Proxy(obj => {
      return this.keys.reduce((acc, key) => {
        return Reflect.get(acc, key)
      }, obj)
    }, handler)
  }
}
```

---

## "Maybe" Properties Start with ï¹©

```js
//Attempting to get/set "company", but fail silently
_.$company.avatar.big
```

### Check if Key Starts with ï¹©

```js
get(target, key){
  if(key.startsWith("$"){
    if(Reflect.has(target, key){
      //apply function and return
    })
    //do nothing
  })
}
```

---

# Immer

## Blending Mutatable and Immutable

---

## Blending Mutatable and Immutable

```js
import produce from "immer"

let nums = [1, 2]

let push3 = produce(draft => {
  draft.push(3)
})

let newNums = push3(nums)
// [1, 2, 3]
```

---

- Create a "draft"
- Mutate the draft
- Return a new object
- Original remains untouched

---

## Elimantes Cloning/Merging

```js
let person = {
  name: "John",
  contact: {
    email: {
      provider: "gmail"
    }
  }
}

let changeProvider = produce(draft => {
  //It doesn't get simpler
  draft.contact.email.provider = "AOL"
})

let personAOL = changeProvider(person)
```

---

## Can Replace Reducers

```js
let todos = [{ name: "Eat" }, { name: "Sleep" }]

let reducer = produce((state, action) => {
  switch (action.type) {
    case "ADD":
      state.push(action.payload)
      break
  }
})

let action = { type: "ADD", payload: { name: "Code" } }
let newTodos = reducer(todos, action)
```

---

### Composes

```js
import { compose } from "ramda"

let person = {
  first: "John"
}

let mindyify = produce(draft => {
  draft.first = "Mindy"
})

let shout = produce(draft => {
  draft.first += "!"
})

let mindyShout = compose(
  shout,
  mindyify
)

let loudMindy = mindyShout(person)
```

---

## Vue 3

```js
// Whatever Evan said before me
// I hope... :)
```
