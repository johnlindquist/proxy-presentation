export { components } from "mdx-deck-code-surfer"
export theme from "./theme"

# Relax

---

# Forget Best Practices

---

# Come with Me on a Journey

---

# Through Metaprogramming

---

> _Programming_

> "code processes user input"

---

> _Metaprogramming_

> "code processes itself"

---

```javascript
let person = { name: "John" }
//The code is looking at itself
Object.keys(person).forEach(key => {
  console.log(key) //"name"
})
----
* > Familiar Metaprogramming
3 > Object.keys processes person
```

---

# This Presentation is About Proxies

> My name is John Lindquist

---

# Proxies are Metaprogramming

> Code that processes itself

---

# Why Should You Care?

Because it opens a whole new world of possibilities

---

```js
let person = {
  first: "John"
}

person = logger(person)

person.first = "Mindy"
----
* > console.logs "first: John - Mindy"
1:3 > Create an object
5 > Invoke a function that returns a Proxy
7 > Assign "first" to "Mindy"
```

---

```js
person.first = "Mindy"

set(target, key, value) {
  // Do whatever you want here!
  target[key] = value
}
----
* > A set trap
1 > Make assignment
3 > Trap assignment!
4:5 > Do _anything_ inside the trap
```

---

```js
set(target, key, value) {
  //Reflection knows if assignment succeeded
  return Reflect.set(target, key, value)
}
----
* > Proper Trap
3 > Use Reflect.set to check success
```

---

```js
person.first = "John"

let handler = {
  set(target, key, value) {
    return Reflect.set(target, key, value)
  }
}
----
* > Traps belong to handlers
3 > The handler
4 > the "set" trap
1[0],4[3] > The Target
1[2],4[5] > The key
1[5],4[7] > The value
```

---

```js
new Proxy(person, handler)
----
* > Proxy receives a Target and a Handler
1[4] > Target
1[6] > Handler
```

---

```js
const logger = obj => {
  let handler = {
    set(target, key, value) {
      console.log(`${key}: ${target[key]} -> ${value}`)
      return Reflect.set(target, key, value)
    }
  }

  return new Proxy(obj, handler)
}
----
* > Full Logger Implementation
4 > Logging logic
```

---

## Sure, logging is useful, but what else can I do?

---

```js
let effect = current => {
  //render, request, whatever!
}

let person = {
  name: "John"
}

person = observable(person, effect)

person.name = "Mindy"
----
* > Callbacks/Reactive
9 > Proxy creation
11 > Make assignment
1:3 > Callback invoked
```

---

```js
export const observable = (obj, callback) => {
  const handler = {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)
      if (success) {
        callback(target)
      }
      return success
    }
  }

  return new Proxy(obj, handler)
}
----
* > Observable implementation
4 > Set the value
5:7 > If "set" works, invoke callback with updated target
```

---

# Bad Ideas

---

```bash
npm i @johnlindquist/has-bad-ideas

----
* > Install my bad ideas

```

---

```js
import { track, review } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = track(person)
----
* > Track and Review
1 > Import track and review
9 > Track creates a Proxy
```

---

```js
person.first = "Mindy"
person.last = "Smith"
person.age = 36
----
* > Make Some Changes
```

---

```js
review(person)
//[Object, Object, Object, Object]
review(person, -1)
//{first: "Mindy", last: "Smith", age: 37}
review(person, -2)
//{first: "Mindy", last: "Lindquist", age: 37}
----
* > Use "review" to view history
1:2 > The entire history
3:6 > Or previous snapshots
```

---

```js
const map = new WeakMap()

export const track = obj => {
  map.set(proxy, [{ ...obj }])

  const proxy = new Proxy(obj, {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)

      if (success) {
        map.set(proxy, [...map.get(proxy), {...target}])
      }

      return success
    }
  })

  return proxy
}
----
* > "track" Implementation
1 > Create a Map to map Proxies to Histories
4 > Store a clone of the intial target
10:12 > Store clones of future targets
```

---

```js
export const review = (proxy, index) => {
  const history = map.get(proxy)
  if (index === undefined) {
    return history
  }
  if (index < 0) {
    return history[history.length + index - 1]
  }
  return history[index]
}

----
* > "review" implementation
2 > get the history from the proxy
4,7,9 > return full history or snapshot
```

---

```js
import { box } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = box(person)

----
* > Lock it in a box
9 > Create a Proxy with "box"
```

---

```js
person.first = "Mindy"
//throws "I'm in a box!"
----
* > Throw an error when attempting "set"
```

---

```js
person.first()
//"John"
person.first("Mindy")
//{...person, first: "Mindy"}
----
* > Instead, all properties are getters/setters
1:2 > Getter
3:4 > Setter

```

---

```js
let shout = str => string.toUpperCase()
person.first(shout)
//{...person, name:"JOHN"}
----
* > Setters also accept functions
1 > A function that uppercases a string
2:3 > Pass the function to the "setter"
```

---

```js
 let handler = {
    set() {
      throw "I'm in a box!"
    },
    [...]
 }

----

 * > The "set" implementation
 2:4 > Don't even try it!
```

---

```js
get(target, key) {
  return value => {
    if (typeof value === "function")
      return new Proxy(
        { ...target, [key]: value(Reflect.get(target, key)) },
        handler
      )
    if (value) {
      return new Proxy({ ...target, [key]: value }, handler)
    }
    return Reflect.get(target, key)
  }
}


----
* > The "get" implementation
2 > Return a function
3,8 > Check the function argument
4:7 > If function, apply to value, return Proxy
9 > If value, set and return Proxy
11 > Or get the value
```

---

```js
person
  .first(shout)
  .last("Smith")
  .age(i => i + 1)
//{first: "JOHN", last: "Smith", age: 38}
----
* > Since "setters" return the Proxy
1 > Let's
2 > chain
3 > together
4 > properties!
5 > ðŸ˜‚
```

---

# Speaking of "chain" ðŸ¤”

---

```js
import { chain } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = chain(person)

----
* > Lodash All the Things ðŸ¤ª
9 > "chain" creates a Proxy
```

---

```js
person.first
  .replace("oh", "a")
  .repeat(3)
  .value()

//"JanJanJan"
----
* > Now every property has all lodash methods!
```

---

```js
import  _ from "lodash"
export const chain = obj => {
  const handler = {
    set() {
      throw "I'm in a box!"
    },
    get(target, key) {
      return _.chain(Reflect.get(target, key))
    }
  }

  return new Proxy(obj, handler)
}
----
* > Full "chain" implementation
8 > Return the wrapped value
```

---

# Pointless? Probably!

---

> We reactive-ed

> We lodash-ed

## What about the lodash of reactive programming...

---

## RxJS Time

```js
import { rxify } from "@johnlindquist/has-bad-ideas"
import { switchMap, mapTo } from "rxjs/operators"
import { interval } from "rxjs"

let person = {
  name: "John"
}

person = rxify(person)
```

---

## Log the Name Every Second

```js
person
  .name(
    switchMap(name => {
      return interval(1000).pipe(mapTo(name))
    })
  )
  .subscribe(console.log)

person.name = "Mindy"
```

https://codesandbox.io/s/7z5j45mwv6

---

## Wat?

```js
let first$ = person.first()
let last$ = person.last()

combineLatest(first$, last$)
  .pipe(map(([first, last]) => `${first} ${last}`))
  .subscribe(console.log)

// "John Lindquist"
// "Mindy Lindquist"
// "Mindy Smith"

person.first = "Mindy"
person.last = "Smith"
```

https://codesandbox.io/s/jvwp7lk5q3

---

## Async Properties? Easy!

<br />

## But how about _dynamic_ async properties!

---

## Create API

```js
import { createApi } from "@johnlindquist/has-bad-ideas"

let api = createApi("https://swapi.co/api")
```

---

Get `/people` from api:

```js
async function main() {
  //'get' request to https://swapi.co/api/people
  let people = await api.people()
}

main()
```

---

Get `/people/1` from api:

```js
//'get' request to https://swapi.co/api/people/1
let person = await api.people(1)
```

https://codesandbox.io/s/73qv66745j

---

# ðŸ’¡ Good Ideas ðŸ’¡

---

## Traditional Lenses

Strings ðŸ¤®

```js
//ramda lens
R.lensPath(["images", "avatar", "big"])
```

<br />

## Lens Proxy

Recursive Trapped Properties ðŸŽ‰

```js
let _ = lensProxy()

_.images.avatar.big
```

---

## Basic Idea

```js
import { lens as _ } from "@johnlindquist/has-bad-ideas"

let provider = _.contact.email.provider
let person = { contact: { email: { provider: "gmail" } } }

let value = provider(person)

console.log(value)
// John
```

---

## Gather Keys, Return Proxies

```js
let handler = {
  keys: [],
  get(target, key) {
    this.keys.push(key)

    return new Proxy(obj => {
      return this.keys.reduce((acc, key) => {
        return Reflect.get(acc, key)
      }, obj)
    }, handler)
  }
}
```

---

## "Maybe" Properties Start

```js
//Attempting to get/set "company", but fail silently
_.$company.avatar.big
```

### Parse Key

```js
get(target, key){
  if(key.startsWith(""){
    if(Reflect.has(target, key){
      //apply function and return
    })
    //do nothing
  })
}
```

---

# Immer

## Blending Mutatable and Immutable

---

## Blending Mutatable and Immutable

```js
import produce from "immer"

let nums = [1, 2]

let push3 = produce(draft => {
  draft.push(3)
})

let newNums = push3(nums)
// [1, 2, 3]
```

---

- Create a "draft"
- Mutate the draft
- Return a new object
- Original remains untouched

---

## Elimantes Cloning/Merging

```js
let person = {
  name: "John",
  contact: {
    email: {
      provider: "gmail"
    }
  }
}

let changeProvider = produce(draft => {
  //It doesn't get simpler
  draft.contact.email.provider = "AOL"
})

let personAOL = changeProvider(person)
```

---

## Can Replace Reducers

```js
let todos = [{ name: "Eat" }, { name: "Sleep" }]

let reducer = produce((state, action) => {
  switch (action.type) {
    case "ADD":
      state.push(action.payload)
      break
  }
})

let action = { type: "ADD", payload: { name: "Code" } }
let newTodos = reducer(todos, action)
```

---

### Composes

```js
import { compose } from "ramda"

let person = {
  first: "John"
}

let mindyify = produce(draft => {
  draft.first = "Mindy"
})

let shout = produce(draft => {
  draft.first += "!"
})

let mindyShout = compose(
  shout,
  mindyify
)

let loudMindy = mindyShout(person)
```

---

## Vue 3

```js
// Whatever Evan said before me
// I hope... :)
```

---

# Summary

---

- Gather Keys
- Dynamic Keys
- Prevent Set
- Get Functions
-
