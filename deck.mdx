export { components } from "mdx-deck-code-surfer"
export theme from "./theme"

# Relax

---

# Forget Best Practices

---

# Come with Me on a Journey

---

# Through Metaprogramming

---

> _Programming_

> "code processes user input"

---

> _Metaprogramming_

> "code processes itself"

---

```javascript
let person = { name: "John" }
//The code is looking at itself
Object.keys(person).forEach(key => {
  console.log(key) //"name"
})
----
* > Familiar Metaprogramming
3 > Object.keys processes person
```

---

# This Presentation is About Proxies

> My name is John Lindquist

---

# Proxies are Metaprogramming

> Code that processes itself

---

# Why Should You Care?

Because it opens a whole new world of possibilities

---

```js
let person = {
  first: "John"
}

person = logger(person)

person.first = "Mindy"
----
* > console.logs "first: John - Mindy"
1:3 > Create an object
5 > Invoke a function that returns a Proxy
7 > Assign "first" to "Mindy"
```

---

```js
person.first = "Mindy"

set(target, key, value) {
  // Do whatever you want here!
  target[key] = value
}
----
* > A set trap
1 > Make assignment
3 > Trap assignment!
4:5 > Do _anything_ inside the trap
```

---

```js
set(target, key, value) {
  //Reflection knows if assignment succeeded
  return Reflect.set(target, key, value)
}
----
* > Proper Trap
3 > Use Reflect.set to check success
```

---

```js
person.first = "John"

let handler = {
  set(target, key, value) {
    return Reflect.set(target, key, value)
  }
}
----
* > Traps belong to handlers
3 > The handler
4 > the "set" trap
1[0],4[3] > The Target
1[2],4[5] > The key
1[5],4[7] > The value
```

---

```js
new Proxy(person, handler)
----
* > Proxy receives a Target and a Handler
1[4] > Target
1[6] > Handler
```

---

```js
const logger = obj => {
  let handler = {
    set(target, key, value) {
      console.log(`${key}: ${target[key]} -> ${value}`)
      return Reflect.set(target, key, value)
    }
  }

  return new Proxy(obj, handler)
}
----
* > Full Logger Implementation
4 > Logging logic
```

---

## Sure, logging is useful, but what else can I do?

---

```js
let effect = current => {
  //render, request, whatever!
}

let person = {
  name: "John"
}

person = observable(person, effect)

person.name = "Mindy"
----
* > Callbacks/Reactive
9 > Proxy creation
11 > Make assignment
1:3 > Callback invoked
```

---

```js
export const observable = (obj, callback) => {
  const handler = {
    set(target, key, value) {
      const success = Reflect.set(target, key, value)
      if (success) {
        callback(target)
      }
      return success
    }
  }

  return new Proxy(obj, handler)
}
----
* > Observable implementation
4 > Set the value
5:7 > If "set" works, invoke callback with updated target
```

---

# Bad Ideas

---

```bash
npm i @johnlindquist/has-bad-ideas

----
* > Install my bad ideas

```

---

```js
import { track, review } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = track(person)
----
* > Track and Review
1 > Import track and review
9 > Track creates a Proxy
```

---

```js
person.first = "Mindy"
person.last = "Smith"
person.age = 36
----
* > Make Some Changes
```

---

```js
review(person) //[Object, Object, Object, Object]
review(person, -1) //{first: "Mindy", last: "Smith", age: 37}
review(person, -2) //{first: "Mindy", last: "Lindquist", age: 37}
----
* > Use "review" to view history
1 > The entire history
2:3 > Or previous snapshots
```

---

## Lock it in a box

```js
import { box } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = box(person)
```

---

## Throw Error on "set"

```js
person.first = "Mindy" //throws "I'm in a box!"
```

---

## All Properties are Getter/Setters

```js
person.first() //"John"
person.first("Mindy") //{...person, first: "Mindy"}
```

---

## Setters Accept Functions

```js
let shout = str => string.toUpperCase()
person.first(shout) //{...person, name:"JOHN"}
```

---

## Chain Together Prop Calls

```js
person
  .first(shout)
  .last("Smith")
  .age(i => i + 1)
//{first: "JOHN", last: "Smith", age: 38}
```

---

# Speaking of "chain" ðŸ¤”

---

## Lodash All the Things ðŸ¤ª

```js
import { chain } from "@johnlindquist/has-bad-ideas"

let person = {
  first: "John",
  last: "Lindquist",
  age: 37
}

person = chain(person)
```

---

## Every Property Has All Lodash Methods

```js
person.first
  .replace("oh", "a")
  .repeat(3)
  .value()

//"JanJanJan"
```

## Pointless? Probably!

---

> We reactive-ed

> We lodash-ed

## What about the lodash of reactive programming...

---

## RxJS Time

```js
import { rxify } from "@johnlindquist/has-bad-ideas"
import { switchMap, mapTo } from "rxjs/operators"
import { interval } from "rxjs"

let person = {
  name: "John"
}

person = rxify(person)
```

---

## Log the Name Every Second

```js
person
  .name(
    switchMap(name => {
      return interval(1000).pipe(mapTo(name))
    })
  )
  .subscribe(console.log)

person.name = "Mindy"
```

https://codesandbox.io/s/7z5j45mwv6

---

## Wat?

```js
let first$ = person.first()
let last$ = person.last()

combineLatest(first$, last$)
  .pipe(map(([first, last]) => `${first} ${last}`))
  .subscribe(console.log)

// "John Lindquist"
// "Mindy Lindquist"
// "Mindy Smith"

person.first = "Mindy"
person.last = "Smith"
```

https://codesandbox.io/s/jvwp7lk5q3

---

## Async Properties? Easy!

<br />

## But how about _dynamic_ async properties!

---

## Create API

```js
import { createApi } from "@johnlindquist/has-bad-ideas"

let api = createApi("https://swapi.co/api")
```

---

Get `/people` from api:

```js
async function main() {
  //'get' request to https://swapi.co/api/people
  let people = await api.people()
}

main()
```

---

Get `/people/1` from api:

```js
//'get' request to https://swapi.co/api/people/1
let person = await api.people(1)
```

https://codesandbox.io/s/73qv66745j

---

# ðŸ’¡ Good Ideas ðŸ’¡

---

## Traditional Lenses

Strings ðŸ¤®

```js
//ramda lens
R.lensPath(["images", "avatar", "big"])
```

<br />

## Lens Proxy

Recursive Trapped Properties ðŸŽ‰

```js
let _ = lensProxy()

_.images.avatar.big
```

---

## Basic Idea

```js
import { lens as _ } from "@johnlindquist/has-bad-ideas"

let provider = _.contact.email.provider
let person = { contact: { email: { provider: "gmail" } } }

let value = provider(person)

console.log(value)
// John
```

---

## Gather Keys, Return Proxies

```js
let handler = {
  keys: [],
  get(target, key) {
    this.keys.push(key)

    return new Proxy(obj => {
      return this.keys.reduce((acc, key) => {
        return Reflect.get(acc, key)
      }, obj)
    }, handler)
  }
}
```

---

## "Maybe" Properties Start

```js
//Attempting to get/set "company", but fail silently
_.$company.avatar.big
```

### Parse Key

```js
get(target, key){
  if(key.startsWith(""){
    if(Reflect.has(target, key){
      //apply function and return
    })
    //do nothing
  })
}
```

---

# Immer

## Blending Mutatable and Immutable

---

## Blending Mutatable and Immutable

```js
import produce from "immer"

let nums = [1, 2]

let push3 = produce(draft => {
  draft.push(3)
})

let newNums = push3(nums)
// [1, 2, 3]
```

---

- Create a "draft"
- Mutate the draft
- Return a new object
- Original remains untouched

---

## Elimantes Cloning/Merging

```js
let person = {
  name: "John",
  contact: {
    email: {
      provider: "gmail"
    }
  }
}

let changeProvider = produce(draft => {
  //It doesn't get simpler
  draft.contact.email.provider = "AOL"
})

let personAOL = changeProvider(person)
```

---

## Can Replace Reducers

```js
let todos = [{ name: "Eat" }, { name: "Sleep" }]

let reducer = produce((state, action) => {
  switch (action.type) {
    case "ADD":
      state.push(action.payload)
      break
  }
})

let action = { type: "ADD", payload: { name: "Code" } }
let newTodos = reducer(todos, action)
```

---

### Composes

```js
import { compose } from "ramda"

let person = {
  first: "John"
}

let mindyify = produce(draft => {
  draft.first = "Mindy"
})

let shout = produce(draft => {
  draft.first += "!"
})

let mindyShout = compose(
  shout,
  mindyify
)

let loudMindy = mindyShout(person)
```

---

## Vue 3

```js
// Whatever Evan said before me
// I hope... :)
```

---

# Summary

---

- Gather Keys
- Dynamic Keys
- Prevent Set
- Get Functions
-
